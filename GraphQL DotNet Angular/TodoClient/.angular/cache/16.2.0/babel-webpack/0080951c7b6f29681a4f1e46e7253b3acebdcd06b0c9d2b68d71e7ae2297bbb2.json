{"ast":null,"code":"import _asyncToGenerator from \"D:/Repos/learn-dotnet/GraphQL_Angular_Subscriptions_V7_6_0/TodoClient/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n *\n * server\n *\n */\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Server\n */\nexport function makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate,\n    execute,\n    subscribe,\n    connectionInitWaitTimeout = 3000,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n        return /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (code, reason) {\n            /* nothing was set up, just notify the closure */\n            yield onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason);\n          });\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n      }\n      // kick the client off (close socket) if the connection has\n      // not been initialised after the specified wait timeout\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage( /*#__PURE__*/function () {\n        var _onMessage = _asyncToGenerator(function* (data) {\n          var _a, e_1, _b, _c;\n          var _d;\n          let message;\n          try {\n            message = parseMessage(data, reviver);\n          } catch (err) {\n            return socket.close(CloseCode.BadRequest, 'Invalid message received');\n          }\n          switch (message.type) {\n            case MessageType.ConnectionInit:\n              {\n                if (ctx.connectionInitReceived) return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                // @ts-expect-error: I can write\n                ctx.connectionInitReceived = true;\n                if (isObject(message.payload))\n                  // @ts-expect-error: I can write\n                  ctx.connectionParams = message.payload;\n                const permittedOrPayload = yield onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx);\n                if (permittedOrPayload === false) return socket.close(CloseCode.Forbidden, 'Forbidden');\n                yield socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                  type: MessageType.ConnectionAck,\n                  payload: permittedOrPayload\n                } : {\n                  type: MessageType.ConnectionAck\n                  // payload is completely absent if not provided\n                }, replacer));\n                // @ts-expect-error: I can write\n                ctx.acknowledged = true;\n                return;\n              }\n            case MessageType.Ping:\n              {\n                if (socket.onPing)\n                  // if the onPing listener is registered, automatic pong is disabled\n                  return yield socket.onPing(message.payload);\n                yield socket.send(stringifyMessage(message.payload ? {\n                  type: MessageType.Pong,\n                  payload: message.payload\n                } : {\n                  type: MessageType.Pong\n                  // payload is completely absent if not provided\n                }));\n\n                return;\n              }\n            case MessageType.Pong:\n              return yield (_d = socket.onPong) === null || _d === void 0 ? void 0 : _d.call(socket, message.payload);\n            case MessageType.Subscribe:\n              {\n                if (!ctx.acknowledged) return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n                const {\n                  id,\n                  payload\n                } = message;\n                if (id in ctx.subscriptions) return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                // if this turns out to be a streaming operation, the subscription value\n                // will change to an `AsyncIterable`, otherwise it will stay as is\n                ctx.subscriptions[id] = null;\n                const emit = {\n                  next: function () {\n                    var _ref2 = _asyncToGenerator(function* (result, args) {\n                      let nextMessage = {\n                        id,\n                        type: MessageType.Next,\n                        payload: result\n                      };\n                      const maybeResult = yield onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result);\n                      if (maybeResult) nextMessage = Object.assign(Object.assign({}, nextMessage), {\n                        payload: maybeResult\n                      });\n                      yield socket.send(stringifyMessage(nextMessage, replacer));\n                    });\n                    return function next(_x4, _x5) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }(),\n                  error: function () {\n                    var _ref3 = _asyncToGenerator(function* (errors) {\n                      let errorMessage = {\n                        id,\n                        type: MessageType.Error,\n                        payload: errors\n                      };\n                      const maybeErrors = yield onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors);\n                      if (maybeErrors) errorMessage = Object.assign(Object.assign({}, errorMessage), {\n                        payload: maybeErrors\n                      });\n                      yield socket.send(stringifyMessage(errorMessage, replacer));\n                    });\n                    return function error(_x6) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }(),\n                  complete: function () {\n                    var _ref4 = _asyncToGenerator(function* (notifyClient) {\n                      const completeMessage = {\n                        id,\n                        type: MessageType.Complete\n                      };\n                      yield onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage);\n                      if (notifyClient) yield socket.send(stringifyMessage(completeMessage, replacer));\n                    });\n                    return function complete(_x7) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }()\n                };\n                try {\n                  let execArgs;\n                  const maybeExecArgsOrErrors = yield onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message);\n                  if (maybeExecArgsOrErrors) {\n                    if (areGraphQLErrors(maybeExecArgsOrErrors)) return yield emit.error(maybeExecArgsOrErrors);else if (Array.isArray(maybeExecArgsOrErrors)) throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                    // not errors, is exec args\n                    execArgs = maybeExecArgsOrErrors;\n                  } else {\n                    // you either provide a schema dynamically through\n                    // `onSubscribe` or you set one up during the server setup\n                    if (!schema) throw new Error('The GraphQL schema is not provided');\n                    const args = {\n                      operationName: payload.operationName,\n                      document: parse(payload.query),\n                      variableValues: payload.variables\n                    };\n                    execArgs = Object.assign(Object.assign({}, args), {\n                      schema: typeof schema === 'function' ? yield schema(ctx, message, args) : schema\n                    });\n                    const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                    if (validationErrors.length > 0) return yield emit.error(validationErrors);\n                  }\n                  const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                  if (!operationAST) return yield emit.error([new GraphQLError('Unable to identify operation')]);\n                  // if `onSubscribe` didnt specify a rootValue, inject one\n                  if (!('rootValue' in execArgs)) execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                  // if `onSubscribe` didn't specify a context, inject one\n                  if (!('contextValue' in execArgs)) execArgs.contextValue = typeof context === 'function' ? yield context(ctx, message, execArgs) : context;\n                  // the execution arguments have been prepared\n                  // perform the operation and act accordingly\n                  let operationResult;\n                  if (operationAST.operation === 'subscription') operationResult = yield (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                  // operation === 'query' || 'mutation'\n                  else operationResult = yield (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                  const maybeResult = yield onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult);\n                  if (maybeResult) operationResult = maybeResult;\n                  if (isAsyncIterable(operationResult)) {\n                    /** multiple emitted results */\n                    if (!(id in ctx.subscriptions)) {\n                      // subscription was completed/canceled before the operation settled\n                      if (isAsyncGenerator(operationResult)) operationResult.return(undefined);\n                    } else {\n                      ctx.subscriptions[id] = operationResult;\n                      try {\n                        for (var _e = true, operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = yield operationResult_1.next(), _a = operationResult_1_1.done, !_a; _e = true) {\n                          _c = operationResult_1_1.value;\n                          _e = false;\n                          const result = _c;\n                          yield emit.next(result, execArgs);\n                        }\n                      } catch (e_1_1) {\n                        e_1 = {\n                          error: e_1_1\n                        };\n                      } finally {\n                        try {\n                          if (!_e && !_a && (_b = operationResult_1.return)) yield _b.call(operationResult_1);\n                        } finally {\n                          if (e_1) throw e_1.error;\n                        }\n                      }\n                    }\n                  } else {\n                    /** single emitted result */\n                    // if the client completed the subscription before the single result\n                    // became available, he effectively canceled it and no data should be sent\n                    if (id in ctx.subscriptions) yield emit.next(operationResult, execArgs);\n                  }\n                  // lack of subscription at this point indicates that the client\n                  // completed the subscription, he doesnt need to be reminded\n                  yield emit.complete(id in ctx.subscriptions);\n                } finally {\n                  // whatever happens to the subscription, we finally want to get rid of the reservation\n                  delete ctx.subscriptions[id];\n                }\n                return;\n              }\n            case MessageType.Complete:\n              {\n                const subscription = ctx.subscriptions[message.id];\n                delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                if (isAsyncGenerator(subscription)) yield subscription.return(undefined);\n                return;\n              }\n            default:\n              throw new Error(`Unexpected message of type ${message.type} received`);\n          }\n        });\n        function onMessage(_x3) {\n          return _onMessage.apply(this, arguments);\n        }\n        return onMessage;\n      }());\n      // wait for close, cleanup and the disconnect callback\n      return /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (code, reason) {\n          if (connectionInitWait) clearTimeout(connectionInitWait);\n          for (const sub of Object.values(ctx.subscriptions)) {\n            if (isAsyncGenerator(sub)) yield sub.return(undefined);\n          }\n          if (ctx.acknowledged) yield onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason);\n          yield onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason);\n        });\n        return function (_x8, _x9) {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n    }\n  };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === 'string' && protocols.split(',').map(p => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","parse","validate","graphqlValidate","execute","graphqlExecute","subscribe","graphqlSubscribe","getOperationAST","GraphQLError","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","stringifyMessage","parseMessage","isObject","isAsyncGenerator","isAsyncIterable","areGraphQLErrors","makeServer","options","schema","context","roots","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","jsonMessageReviver","reviver","jsonMessageReplacer","replacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","_ref","_asyncToGenerator","code","reason","_x","_x2","apply","arguments","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","_onMessage","data","_a","e_1","_b","_c","_d","message","err","BadRequest","type","ConnectionInit","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","Ping","onPing","Pong","onPong","Subscribe","Unauthorized","id","SubscriberAlreadyExists","emit","next","_ref2","result","args","nextMessage","Next","maybeResult","Object","assign","_x4","_x5","error","_ref3","errors","errorMessage","Error","maybeErrors","_x6","complete","_ref4","notifyClient","completeMessage","Complete","_x7","execArgs","maybeExecArgsOrErrors","Array","isArray","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","undefined","_e","operationResult_1","operationResult_1_1","e_1_1","subscription","_x3","_ref5","clearTimeout","sub","values","_x8","_x9","handleProtocols","protocols","Set","has","includes","split","map","p","trim"],"sources":["D:/Repos/learn-dotnet/GraphQL_Angular_Subscriptions_V7_6_0/TodoClient/node_modules/graphql-ws/lib/server.mjs"],"sourcesContent":["/**\n *\n * server\n *\n */\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError, } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage, } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors, } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Server\n */\nexport function makeServer(options) {\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\n    return {\n        opened(socket, extra) {\n            const ctx = {\n                connectionInitReceived: false,\n                acknowledged: false,\n                subscriptions: {},\n                extra,\n            };\n            if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n                socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n                return async (code, reason) => {\n                    /* nothing was set up, just notify the closure */\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n                };\n            }\n            // kick the client off (close socket) if the connection has\n            // not been initialised after the specified wait timeout\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\n                ? setTimeout(() => {\n                    if (!ctx.connectionInitReceived)\n                        socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n                }, connectionInitWaitTimeout)\n                : null;\n            socket.onMessage(async function onMessage(data) {\n                var _a, e_1, _b, _c;\n                var _d;\n                let message;\n                try {\n                    message = parseMessage(data, reviver);\n                }\n                catch (err) {\n                    return socket.close(CloseCode.BadRequest, 'Invalid message received');\n                }\n                switch (message.type) {\n                    case MessageType.ConnectionInit: {\n                        if (ctx.connectionInitReceived)\n                            return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                        // @ts-expect-error: I can write\n                        ctx.connectionInitReceived = true;\n                        if (isObject(message.payload))\n                            // @ts-expect-error: I can write\n                            ctx.connectionParams = message.payload;\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n                        if (permittedOrPayload === false)\n                            return socket.close(CloseCode.Forbidden, 'Forbidden');\n                        await socket.send(stringifyMessage(isObject(permittedOrPayload)\n                            ? {\n                                type: MessageType.ConnectionAck,\n                                payload: permittedOrPayload,\n                            }\n                            : {\n                                type: MessageType.ConnectionAck,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        // @ts-expect-error: I can write\n                        ctx.acknowledged = true;\n                        return;\n                    }\n                    case MessageType.Ping: {\n                        if (socket.onPing)\n                            // if the onPing listener is registered, automatic pong is disabled\n                            return await socket.onPing(message.payload);\n                        await socket.send(stringifyMessage(message.payload\n                            ? { type: MessageType.Pong, payload: message.payload }\n                            : {\n                                type: MessageType.Pong,\n                                // payload is completely absent if not provided\n                            }));\n                        return;\n                    }\n                    case MessageType.Pong:\n                        return await ((_d = socket.onPong) === null || _d === void 0 ? void 0 : _d.call(socket, message.payload));\n                    case MessageType.Subscribe: {\n                        if (!ctx.acknowledged)\n                            return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n                        const { id, payload } = message;\n                        if (id in ctx.subscriptions)\n                            return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                        // if this turns out to be a streaming operation, the subscription value\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\n                        ctx.subscriptions[id] = null;\n                        const emit = {\n                            next: async (result, args) => {\n                                let nextMessage = {\n                                    id,\n                                    type: MessageType.Next,\n                                    payload: result,\n                                };\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                                if (maybeResult)\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\n                                await socket.send(stringifyMessage(nextMessage, replacer));\n                            },\n                            error: async (errors) => {\n                                let errorMessage = {\n                                    id,\n                                    type: MessageType.Error,\n                                    payload: errors,\n                                };\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                                if (maybeErrors)\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\n                                await socket.send(stringifyMessage(errorMessage, replacer));\n                            },\n                            complete: async (notifyClient) => {\n                                const completeMessage = {\n                                    id,\n                                    type: MessageType.Complete,\n                                };\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                                if (notifyClient)\n                                    await socket.send(stringifyMessage(completeMessage, replacer));\n                            },\n                        };\n                        try {\n                            let execArgs;\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                            if (maybeExecArgsOrErrors) {\n                                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                                    return await emit.error(maybeExecArgsOrErrors);\n                                else if (Array.isArray(maybeExecArgsOrErrors))\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                                // not errors, is exec args\n                                execArgs = maybeExecArgsOrErrors;\n                            }\n                            else {\n                                // you either provide a schema dynamically through\n                                // `onSubscribe` or you set one up during the server setup\n                                if (!schema)\n                                    throw new Error('The GraphQL schema is not provided');\n                                const args = {\n                                    operationName: payload.operationName,\n                                    document: parse(payload.query),\n                                    variableValues: payload.variables,\n                                };\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\n                                        ? await schema(ctx, message, args)\n                                        : schema });\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                                if (validationErrors.length > 0)\n                                    return await emit.error(validationErrors);\n                            }\n                            const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                            if (!operationAST)\n                                return await emit.error([\n                                    new GraphQLError('Unable to identify operation'),\n                                ]);\n                            // if `onSubscribe` didnt specify a rootValue, inject one\n                            if (!('rootValue' in execArgs))\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                            // if `onSubscribe` didn't specify a context, inject one\n                            if (!('contextValue' in execArgs))\n                                execArgs.contextValue =\n                                    typeof context === 'function'\n                                        ? await context(ctx, message, execArgs)\n                                        : context;\n                            // the execution arguments have been prepared\n                            // perform the operation and act accordingly\n                            let operationResult;\n                            if (operationAST.operation === 'subscription')\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                            // operation === 'query' || 'mutation'\n                            else\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                            if (maybeResult)\n                                operationResult = maybeResult;\n                            if (isAsyncIterable(operationResult)) {\n                                /** multiple emitted results */\n                                if (!(id in ctx.subscriptions)) {\n                                    // subscription was completed/canceled before the operation settled\n                                    if (isAsyncGenerator(operationResult))\n                                        operationResult.return(undefined);\n                                }\n                                else {\n                                    ctx.subscriptions[id] = operationResult;\n                                    try {\n                                        for (var _e = true, operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), _a = operationResult_1_1.done, !_a; _e = true) {\n                                            _c = operationResult_1_1.value;\n                                            _e = false;\n                                            const result = _c;\n                                            await emit.next(result, execArgs);\n                                        }\n                                    }\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                    finally {\n                                        try {\n                                            if (!_e && !_a && (_b = operationResult_1.return)) await _b.call(operationResult_1);\n                                        }\n                                        finally { if (e_1) throw e_1.error; }\n                                    }\n                                }\n                            }\n                            else {\n                                /** single emitted result */\n                                // if the client completed the subscription before the single result\n                                // became available, he effectively canceled it and no data should be sent\n                                if (id in ctx.subscriptions)\n                                    await emit.next(operationResult, execArgs);\n                            }\n                            // lack of subscription at this point indicates that the client\n                            // completed the subscription, he doesnt need to be reminded\n                            await emit.complete(id in ctx.subscriptions);\n                        }\n                        finally {\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\n                            delete ctx.subscriptions[id];\n                        }\n                        return;\n                    }\n                    case MessageType.Complete: {\n                        const subscription = ctx.subscriptions[message.id];\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                        if (isAsyncGenerator(subscription))\n                            await subscription.return(undefined);\n                        return;\n                    }\n                    default:\n                        throw new Error(`Unexpected message of type ${message.type} received`);\n                }\n            });\n            // wait for close, cleanup and the disconnect callback\n            return async (code, reason) => {\n                if (connectionInitWait)\n                    clearTimeout(connectionInitWait);\n                for (const sub of Object.values(ctx.subscriptions)) {\n                    if (isAsyncGenerator(sub))\n                        await sub.return(undefined);\n                }\n                if (ctx.acknowledged)\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n            };\n        },\n    };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n    switch (true) {\n        case protocols instanceof Set &&\n            protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case Array.isArray(protocols) &&\n            protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case typeof protocols === 'string' &&\n            protocols\n                .split(',')\n                .map((p) => p.trim())\n                .includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n            return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}