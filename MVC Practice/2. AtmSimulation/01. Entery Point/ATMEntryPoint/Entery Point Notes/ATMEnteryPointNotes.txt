

/////////////////////////////////////////////////////////////////////////////////////////////////
										Entry Point
/////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
			 Understanding Controler Actions
////////////////////////////////////////////////////////////////////
 
 1. Open the Controlers Folder
	a. there are two files in tutorial but three after in update

2. go in Home Controler and lets check this shit out
	a. because this is the Home Controller so any request made in the browser with 
	 /home/ will be handled by this controller. so for example if we have a ShitController all the 
	 /shit/ requests will be controled by that controler
	 IF AN APPROPREATE ONE CAN BE FOUND

3. when we create new controllers we wanna make sure that the World Controller Is in the class name
	so we can take advantage or this convention automaticly
	For example:
	  we can make a // GET request by doing /home/index
	  same we can do with // Get  /home/about

4. This mapping of Requests to ActionMethods is Called Routing.
   we'll study that in next vid


5. Our ActionMethods usually Return ActionResult that's an abstract calss
	 and our action Methods will be returning a number of of different type of objects
	 that All inherit from this class and can be executed in some way to produce a result
	 eg. Some plain text, File to download, JSON to process  or JS to execute
	   BUT in default case its a view.
	    When we call the View() without any parameters it 
		it will look for a view who's name matches the name of the controler
		 cause we are in Home Controller it will look for a view .cshtml in the Views/Home/Index.cshtml
  	and by chance if you have a SHit Controller 
	its index will look for an index in Views/Shit/Index.cshtml

6. So yeah everything will be devided in to Small pieces of HTML more like fragments
	but the Main Layout of the page will be located in the folder called
	Views/Shared/_Layout.cshtml 
	includes html,head,body etc

7. To re-enforce the concept of invoking actions rather than always requesting 
	pages, files or views to render lets make a new ActionMEthod to HomeController
	called Shit
	> yes it will give an error because we don't have a layout called SHit
	>  So we can also Redirect it or use it as na Alias for some other action
	> To redirect the Page just pass in some parameter like 
	  View("About"); or whatever other view you have 
8. At this point if your wondering about Parameters that might pe passed to the ActionMethods
   meaning QueryStringParameters and PostParameters we'll talk about those in the Next vid 
   when we take a closer Look at How Routing engin works
///////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
			 Exploring ASP.NET Routing
////////////////////////////////////////////////////////////////////

> Lets see the how we can Configure the Mapping of webrequests to Controller actions 
  which is known as routing
> Asp.Net rellys on URL Pattrens to indentify which controller action will 
  handle a given request.
   we've seen home/index and home/about
    > we can say these are home/{action} 
	  where action is the name of the ActionMethod Of the homeController
	> to make it more General we can say they match the pattren
	   {controller}/{action}
	   in this form controller is the first part of the controller Class name
    > but(shikashi)
	 in our routing rules we can add some more pieces or segments as we call them
	  {controller}/{action}/{id}
	 something generated by default is an optional Id parameter.
	>
1. Open App_Start see and Open RoutConfig.cs
    > It has a single method called Register Routes. Which is called When your application is Started
	   you can see that if you look at the Global.apxs > Application_start() method
2. The reason we have route.IgnoreRoute in it is because any request.axd
   in them are going to be for certain resources or system Utilities
   and will be dealt by a completely seperate handler
   > The * before pathInfo means we wanna use the last segment in this pattren as a catch all
     thats we don't wanna match just a single token after axd/ 
	 but any sequance of characters even if they're are additional slashes in it
   > then we have a call to MapRout thats using named parameters by default
	 to make it easier to read it has
	  name : default
	  url pattren :{controller}/{action}/{id}
	  and
	  then a generic object for default parameter that identifyies 
	   the default values to be used if a controller and an action are not specified
	   according to this pattren it also indecates that the id parameter is optional
	   defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
    > The MapRout() method has a number of overloads   
	  lets setup another Route   
	   purpose of Route :
	      Identify URL that someone can use to retrieve the serial number 
		  of Our ATM
		  	routes.MapRoute(
                name: "Serial number",
                url: ,
                defaults: 
            );

		we'll be putting corosponding action in the HomeController but lets suppose
		we don't want home to be the part of the request path and we just want to be invoked with 
			/serial
			if thats the case we can ause Serial for the Url
			routes.MapRoute(
                name: "Serial number",
                url: "serial",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );
		but lets go and add a parameter that will allow the user to request a different format of the 
		serial number maybe like a lower case serial number
			so we'll pass it a placeholder object
			url: "serial/{letterCase}",
		then for Defaults 
		                              homeControler	----- serialAction -- default for letterCase 
           defaults: new { controller = "Home", action = "Serial", letterCase ="upper" }
			
 3. when processing a request the routing engin will always use the first route that can find that matches
	 so if you define a custom route make sure you put it above the default generated route
	  because if you don't do that the routing engine will try to find an action such as serial/index that doesn't exist
	  so its just to resolve the 404 error
	  so if you put the custom rout first that will cause it to be chossen first if it matches
4. you can also 
			routes.MapRoute(
               name: "Serial number",
                url: "serial",
                defaults: new { controller = "Home", action = "Serial" }
            );
    use querystrings 
	 or post parameters in the url if you don't have the defaults or the 
	  // lets do it and make something like shit small and shit big query
	  http://localhost:2304/shit?shitCase=lower  this is how query string works
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
			 Understanding Action Result Types
////////////////////////////////////////////////////////////////////

> There are a different Types of ActionResults that can be returned from a COntroller
  By defining the retub type of an action as action result we could choose
  to return different types in different senerios in the same method
   For example if we don't wanna return the lowercase of our serial number we might return
    and HttpStatusCodeResult(403); // to tell that the user ins't authorised to see the thing
> there are Some common result types
	> ViewResult - renders a complete Web page
	> PartialViewResult - renders a section of a web page
	   its used if we want to seperate a view from its layout for some reason
	   maybe to embed it in another view
	   lets Make Change to index of Home controller and return a partial view
	    it just removes the _layout file of the partial view including all the css and java script
	> ContentResult - returns user-defined content(text,xml)
	> JsonResult - returns JSON Object
	 we can return an annoynomus object but for security reasons
	  we will have to explicitly allow JsonReques
      		return Json(new { name = "shit", value = shit }, JsonRequestBehavior.AllowGet);
   	> RedirectToRouteResult - issues a redirect to another action
	  To redirect to a totally different action or  action of a different controller all together
	   return RedirectToRouteResult("Index");
	  For complete list of action result types  msdn.microsoft.com
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
			 Applying Action Selectors
////////////////////////////////////////////////////////////////////
 
> Use of action selectors
  Action Selectors are the type of attributes that you can use to decorate your Controller Methods
  in order to help the routing engine determin which one to select to serve a Request in cases where
  it might be otherwise unclear.
  e.g.
   // this means that the below mehthod will be only invoked in the response 
   // to an HTTP POST Request
  [HttpPost]
  public ActionResult Create(Customer cust){
		db.customers.add(cust);
		return RedirectToAction("Index");
  }

  // the reason why we need to identify the above method 
  // because we probably will also have a get method
  // and its because we want it to have a method with same name 
  // for get requests
  // we want the users to be able to use the Create action and have 
  // a blank form be displayed for them this action will acomplish that
  // by returning a view
   >> in Practice we don't really need to explixitly indicate which actions are GetActions
      meaning its good to know rather than not knowing. 
	  and when we make a POST request the routing engine will ignore the one
	  without the HTTP verb Action Selector
   [HttpGet]
   public ActionResult Create(Customer cust){
		return View();
   }

1. lets add a contact form to our contact view
2. add some code to HomeController

  > ViewBag 
    The ViewBag is a dynamic object that is used to pass information
	between the controller and the view that doesn't belong in a model
	since its not real application data its a little bit like a session object
	but its going to be disposed out as soon as our view is rendered
	and its only available if we return a view at the end of our method
	if we redirect to another action or do something else all the viewbag properties that 
	we set will no longer be available.
	 > if we need somethign that would survive a redirect we can use the TempData["key"] = "message";
	but since viewBag is a dynamic object we can add properties to it instead of using string keys
	eg 
	change in homecontroller contact Action with HttpPost Action selector

> There is also an ActionName Attribute that we can use to make our metods invokable using 
   ulternative names. 
    eg

		[ActionName("Fuck-SHit//About")]
        // Get /home/about
        public ActionResult About()
        {
            ViewBag.Message = "Your application description page.";
            return View();
        }
		// it will have a problem and it will find the ViewNamed "Fuck-SHit//About" so we will have to 
			explisitly tell the view where still looking for about view
			we can simply do that by return View("About");
> with MVC 5 its possible to set routing attributes on the action methods
  instead of using route config
  its called Attribute Routing

  [Route("home/create")]
  public ActionResult Create(){
     return view();
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
						Using  Filters
////////////////////////////////////////////////////////////////////
 Another way to modify action in MVC.net is by using Filters
1. Common Filter Types:

	> Authorization Filter :
			It allows you to specify what users of Groups have access to a preticular method or
			Controller.
	 eg. Builtin Authorize Attribute
		 this attribute can take several optional parameters including 
		 roles and list of users who are authorized to execute anaction
		 and we can stack these filters right on top of the Http Post selector
			
			// in this example we're indicating anyone who is an administrator role or is 
			 a user named 'jsmith' can use this actionand is authorized

			[Authorize(Roles="administrator",Users="jsmith")]
			[HttpPost]
	        public ActionResult Create(Customer cust){
				db.customers.add(cust);
				return RedirectToAction("Index");
			}

			// if you just requre a user to be logged in and deny access to annonymous visitors
			  Use an authorize attribute without parameters

			  
			[Authorize] // allows any logged-in user
			[HttpPost]
			public ActionResult Create(Customer cust){
				db.customers.add(cust);
				return RedirectToAction("Index");
			}

	> Action Filter :
                	////////////////////////////////////////////////////////////////////////
					Custom Action FIlters
			////////////////////////////////////////////////////////////////////////
		Action Filter is a filter Applied as ActionMethod Attribute but technicaly
		 an Action filter is One that Wraps the Execution of the Body of The Action
		 and its applied after the [Authorization] Filter

		 so if we need some code to be Executed either before or after an  Action is Executed
		  or at both points we can create a Custom Action Filter by following some simple steps
		  > Create a Class that Inherits from ActionFilterAttribute class 
		  > Override OnActionExecuting method  // for the code that should run before the action
		  > Override OnActionExecuted method  // for code that should run after action execution
		
		eg.
		  // A filter that will log all the successful requests  for an action that its applied to
		 public Class MyLoggingFilterAttribute : ActionFilterAttribute{
		 
		    // to run after action is executed
			public override void OnActionExecuted(ActionExecutedContext filterContext){
					
				var request = filterContext.HttpContext.Request;
				Logger.logRequest(request.UserHostAddress); // to get the Ip address of the user
				base.OnActionExecuted(filterContext); // call the baseclasses method
			}

		 }
	  
	   // now we can apply this to an action or a whole controller 
	   [MyLoggingfilter] // yeah you don't need to include the word Attribute here even though it was in your class name
	   public ActionResult Index(){
			return View();
	   }

	> Result Filter :
	   These wrap execution of the actual result of an action. a builtin example is 
	   [OutputCache(Duration=1800)] attrubute

	   // we can do some very powerfull things with it
	   // like cache an action result for a specified duration in seconds
	   // like so
	   [OutputCache(Duration=1800)]
	   public ActionResult Index() {
			return View();
	   }

	   // or we can even tell it that a different version should be cached for each parameter value
	   // or maybe give a combination of parameters and we can specify a semicolon delimeted list there
	   [OutputCache(Duration=1800 , VaryByPram="id")]
	   public ActionResult Details(int id) {
	    Product p = db.Products.Find(id);
			return View(p);
	   }

	> Exception Filters :
		Exception Filters run when unhandled exceptions are thrown during the execution of an Action
		one builtin Example is the HandleErrorAttribute(); which is applied in our project in 
		Filter.Config.cs Class and in RegisterGlobalFilters(){} method
		this filter is supposed to have an effect to redirect the user to an error view
		which is in View/Shared/Error.cshtml 

		lets do a little experiment

		open HomeController and in index() method
		 throw new StackOverflowException();
		 // you'll see a stackOverFlow exception in the YelloScreenOf F**k
		 and that isn't the Error.cshtml view
		 
		 // what just happend is 
		  By default when the request comes from the same server on which the application is running on
		  its going to assume that its safe to show this detailed error information 
		  this is called the yello screen of F***
		  it actually displays some of our code to the end user

		 // in case you want to see what it looks like to the remote user 
		   and not a developer working on the same server
		 > Go to Web.config
		 > add a <customErros> element inside the <system.web> element
		 > The default mode is remoteOnly // it means custom error page for user and detaild yellow shit for developer
		   We can force the custom erros page by setting this to on
		 > afer editing the web.config restart the page and see the error view

      Even though this controller is already applied you might want to apply some different Error view for 
	   some different action 
	   you can do that byusing the View parameter
	   eg.
	   		[HandleError(View="MyError"] 
			[HttpPost]
	        public ActionResult Create(Customer cust){
				db.customers.add(cust);
				db.SaveChanges();
				return RedirectToAction("Index");
			}
		// and we can also specify different type of error views for different Exceptions

			[HandleError(View="MathError",ExceptionType= typeof(DivideByZeroException))] 
			[HandleError(View="SOError",ExceptionType= typeof(StackOverFlowException))] 
			[HttpPost]
	        public ActionResult Create(Customer cust){
				db.customers.add(cust);
				db.SaveChanges();
				return RedirectToAction("Index");
			}
			 //  in this the MathErrror will display the MathError view
			 //  the So error will display SOError view
			 // and any other error will be handled by the GlobalError view
			 
			 try that on your own

2. These attributes can also beused to decorate a controller class and be used as a Controller-level Filter
	
	for example 

	[Authorize] 
	public class SomeController : Controller{

		// need to be logged in to  use this 
		public ActionResult Create(){
		// only authorized users can execute this controller
		}

		// override the [Authorize] to allow any user who's not logged int 
		//  and provide them access to this page
		[AllowAnonymous]
		public ActionResult Help(){
		// any visitor can view this page 
		}
	
	}
   
3. In addition to Authorization we can also handle Authentication at the Controller-Level
    with an Authentication ActionFilter in MVC 5. We'll be focusing on more common application level
	authentication when we'll talk about Security

 
 4. We can also Apply a filter Globally to the whole application(every action in the application)
	to do that find the FilterConfig.cs class in the App_Start folder
	and in side the RegisterGlobalFilters(){...} method we can add this like
	   public static void RegisterGlobalFilters(GlobalFilterCollection filters)
        {
            filters.Add(new HandleErrorAttribute()); // we'll talk about this later
            //filters.Add(new MyLoggingFilterAttribute());
        }


////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////