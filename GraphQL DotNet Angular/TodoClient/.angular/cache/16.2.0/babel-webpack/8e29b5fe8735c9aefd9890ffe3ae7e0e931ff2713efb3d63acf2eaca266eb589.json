{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from '../../utilities/globals/index.js';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { Kind } from 'graphql';\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField } from '../../utilities/index.js';\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from './helpers.js';\nimport { canonicalStringify } from './object-canon.js';\nimport { normalizeReadFieldOptions } from './policies.js';\n;\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n  return flavored;\n}\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader, fragments) {\n    this.cache = cache;\n    this.reader = reader;\n    this.fragments = fragments;\n  }\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      variables = _a.variables,\n      overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var context = __assign(__assign({\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables)\n    }, extractFragmentContext(query, this.fragments)), {\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    });\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n    if (!isReference(ref)) {\n      throw newInvariantError(9, result);\n    }\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n        mergeTree = _a.mergeTree,\n        fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          return;\n        }\n        storeObject = applied;\n      }\n      if (globalThis.__DEV__ !== false && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n      store.merge(dataId, storeObject);\n    });\n    store.retain(ref.__ref);\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    var incoming = Object.create(null);\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n      return policies.readField(options, context);\n    };\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n      var _a;\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n        var childTypename = void 0;\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n        if (merge) {\n          childTree.info = {\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (globalThis.__DEV__ !== false && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {\n        globalThis.__DEV__ !== false && invariant.error(10, resultKeyNameFromField(field), result);\n      }\n    });\n    try {\n      var _b = policies.identify(result, {\n          typename: typename,\n          selectionSet: selectionSet,\n          fragmentMap: context.fragmentMap,\n          storeObject: incoming,\n          readField: readField\n        }),\n        id = _b[0],\n        keyObject = _b[1];\n      dataId = dataId || id;\n      if (keyObject) {\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      if (!dataId) throw e;\n    }\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n      var previous_1 = context.incomingById.get(dataId);\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n      return dataRef;\n    }\n    return incoming;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n    }\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false);\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n          deferred = inheritedContext.deferred;\n        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n            }\n          });\n        }\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n          if (existing) {\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(11, selection.name.value);\n          }\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n    return fieldMap;\n  };\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n    var _this = this;\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      var i_1 = incoming;\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n      var changedFields_1;\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n      if (changedFields_1) {\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n    return incoming;\n  };\n  return StoreWriter;\n}();\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  globalThis.__DEV__ !== false && invariant.warn(12, fieldName, parentType, childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", typeDotName, existing, incoming);\n}","map":{"version":3,"names":["__assign","invariant","newInvariantError","equal","Trie","Kind","getFragmentFromSelection","getDefaultValues","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","isNonEmptyArray","argumentsObjectFromField","isArray","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","extractFragmentContext","canonicalStringify","normalizeReadFieldOptions","getContextFlavor","context","clientOnly","deferred","key","concat","flavored","flavors","get","set","StoreWriter","cache","reader","fragments","prototype","writeToStore","store","_a","_this","query","result","dataId","variables","overwrite","operationDefinition","merger","written","Object","create","merge","existing","incoming","varString","incomingById","Map","ref","processSelectionSet","selectionSet","mergeTree","map","forEach","storeObject","fieldNodeSet","entityRef","size","applied","applyMerges","globalThis","__DEV__","fieldsWithSelectionSets_1","field","name","value","hasSelectionSet_1","storeFieldName","hasMergeFunction_1","childTree","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","typename","rootTypenamesById","fragmentMap","__typename","readField","options","arguments","from","result_1","Set","flattenFields","resultFieldKey","add","getStoreFieldName","fieldName","getChildMergeTree","incomingValue","processFieldValue","childTypename","getMergeFunction","maybeRecycleChildMergeTree","added","getReadFunction","error","_b","identify","id","keyObject","e","dataRef","sets","indexOf","push","isFresh","previous_1","mergeMergeTrees","mergeTreeIsEmpty","item","i","fieldMap","limitingTrie","flatten","inheritedContext","visitedNode","lookup","visited","selections","selection","directives","dir","args","if","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","getFieldValue","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","has","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","warn","length","join"],"sources":["D:/Repos/learn-dotnet/GraphQL_Angular_Subscriptions_V7_6_0/TodoClient/node_modules/@apollo/client/cache/inmemory/writeToStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from '../../utilities/globals/index.js';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { Kind, } from 'graphql';\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, } from '../../utilities/index.js';\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from './helpers.js';\nimport { canonicalStringify } from './object-canon.js';\nimport { normalizeReadFieldOptions } from './policies.js';\n;\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&\n            context.deferred === deferred) ? context : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));\n    }\n    return flavored;\n}\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map, clientOnly: false, deferred: false, flavors: new Map });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(9, result);\n        }\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    return;\n                }\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        var incoming = Object.create(null);\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, field.selectionSet\n                    ? getContextFlavor(context, false, false)\n                    : context, childTree);\n                var childTypename = void 0;\n                if (field.selectionSet &&\n                    (isReference(incomingValue) ||\n                        storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (globalThis.__DEV__ !== false &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && invariant.error(10, resultKeyNameFromField(field), result);\n            }\n        });\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            dataId = dataId || id;\n            if (keyObject) {\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false);\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (!(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(11, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = (!isArray(incoming) &&\n                (isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;\n            var i_1 = incoming;\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return isArray(from)\n                    ? (typeof name === \"number\" ? from[name] : void 0)\n                    : context.store.getFieldValue(from, String(name));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map;\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map :\n        left.map.size ? left.map : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (isReference(existing))\n        return;\n    if (equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!isArray(existing) &&\n        !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && invariant.warn(12, fieldName, parentType, childTypenames.length\n        ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, existing, incoming);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}